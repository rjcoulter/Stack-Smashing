Notes on "Smashing the Stack for Fun and Profit" by Aleph One

Introduction
- Explain what buffer overflows are and how they work
- Buffer -> Contiguous block of computer memory that holds multiple
  instances of some data type, associated with word buffer
  arrays
- Arrays can be either static or dynamic
  - Stacic -> allocated at load time on data segment
  - Dynamic -> allocated at run time on the stack
- We are concered only with overflows of dynamic buffers, ie 
  stack-based buffer overflows

Process Memory Organization
- Processes are divided into three regions
  - Text, Data, and Stack
- Text Region -> Fixed by the program, includes the code and 
  read only data, the text section of the executable file
  - Normally marked read only, any write attempt to it will cause a 
    segfault
- Data Region -> Contains intialized and unintialized data, static
  variables are stored in this region
  - Corresponds to the data-bss section of an executable file
  - Can use the brk(2) system call to change its size
- Stack Region -> Abstract data type, LIFO
  - Ie, last object put in the stack is the first removed
  - Two most important ops are push (add to top) and pop (remove from top)



                      /------------------\ lower
                      |                  | memory
                      |       Text       | addresses
                      |                  |
                      |------------------|
                      | (Initialized)    |
                      |       Data       |
                      | (Uninitialized)  |
                      |------------------|
                      |                  |
                      |     Stack        | higher
                      |                  | memory
                      \------------------/ addresses

Why use a Stack?
- Modern computers are designed with high level languages in mind
- Most important feature of these languages is the function (procedure)
  - Procedure call alters the flow of control like a jump
  - Unlike a jump, when finished, a function returns control to the 
    statement/instruction following the call
  - This abstraction is implemented with the help of a stack, the 
    stack dyanmically allocates local vars used in functions, pass
    parameters to the functions, and returns values from functions

The Stack Region
- Stack is a contiguous block of memory containing data
- Regsiter called the stack pointer (SP) points to the top of the stack
- The bottom of the stack is at a fixed address
- The size is dynamically adjusted by the kernel at run time
- CPU impements instructions to PUSH onto and POP off the stack
- The stack consists of logical stack frames that are pushed when
  calling a function, and then popped when returning 
  - Stack frames contains the parameters to a function, its local
    variables, and the data needed to recover the previous stack 
    frame, including the value of the instruction pointer at the time
    of a function call
- Stack grows up or down depending on implementation
- SP also depends on implementation, may point at the last address
  on the stack or the next available address
- Frame Pointer (FP) points to a fixed location within a frame,
  sometimes reffered to as a local base pointer (LB)
  - Local data when referenced by its offset from FP do not change
    with PUSHes and POPs, less overhead than using the offset from 
    the SP
  - Actual parameters have positive offsets and local variables
    have negative offsets from FP
- When a procedure is called (Procedure Prolog):
  - It saves the previous FP (to be restored at procedure exit)
  - It then copies SP into FP to create the new FP
  - It then advances SP to reserve space for local variables
- The clean up done after is the procedure epilog

Layout of memory from example1.c
- Memory can only be addressed in multiples of the word size
  - In our case (Linux x86) a word is 4 bytes, or 32 bits
- 5 byte buffer1 -> 8 bytes of memory
- 10 byte buffer2 -> 12 bytes of memory

bottom of                                                     top of
memory                                                        memory
        buffer2          buffer1   sfp   ret   a     b     c
<------ [              ][        ][    ][    ][    ][    ][    ]
top of                                                        bottom of
stack                                                         stack

Buffer Overflows
- The result of stuffing more data into a buffer than it can handle
- strcpy() copies the contents of larger_string into buffer until
  a null character is found on the string
- The buffer is 16 bytes long, and we are trying to stuff 256 bytes
  into it
- All 240 bytes in the stack after the buffer are being overwriten
- The return address will now be 0x41414141 (Hex character value of 'A' is 0x41)
  - This is outside the process address space, which is why when
    the function returns and tries to read the instruction from that
    address there is a segfault
- A buffer overflow lets us change the return address of a function,
  altering the flow of execution of the program

Stack layout from example2.c

bottom of                                                     top of
memory                                                        memory
         buffer        sfp   ret   *str     
<------ [            ][    ][    ][    ]   
top of                                                        bottom of
stack                                                         stack














